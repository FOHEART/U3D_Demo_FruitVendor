enum ChannelOrder{
	XYZ,
	XZY,
	YXZ,
	YZX,
	ZXY,
	ZYX,
	NONE
};

void QuatToEular::EulerToQuat(float x, float y, float z, ChannelOrder RotOrder, float* fData)
{
	float RotMatrix[9];
	float XR, YR, ZR;
	
	switch (RotOrder)
	{
	case ZXY:
	{
		XR = x / 180 * PI;
		YR = y / 180 * PI;
		ZR = z / 180 * PI;

		float SX = sin(XR);
		float CX = cos(XR);
		float SY = sin(YR);
		float CY = cos(YR);
		float SZ = sin(ZR);
		float CZ = cos(ZR);

		RotMatrix[0] = CY*CZ - SX*SY*SZ;
		RotMatrix[1] = -CX*SZ;
		RotMatrix[2] = CZ*SY + CY*SX*SZ;
		RotMatrix[3] = CZ*SX*SY + CY*SZ;
		RotMatrix[4] = CX*CZ;
		RotMatrix[5] = SY*SZ - CY*CZ*SX;
		RotMatrix[6] = -CX*SY;
		RotMatrix[7] = SX;
		RotMatrix[8] = CX*CY;
		break;
	}
	
	default:
		break;
	}

	fData[0] = 0;
	fData[1] = 0;
	fData[2] = 0;
	fData[3] = 1;

	rotation2quat(fData, RotMatrix);
}

void QuatToEular::rotation2quat(float* q, float* rotmat)
{
	float T = 1 + rotmat[0] + rotmat[4] + rotmat[8];

	// Calculate quaternion based on largest diagonal element
	if (T > (0.00000001))
	{
		float S = 0.5f / sqrt(T);
		q[3] = .25f / S;
		q[0] = (rotmat[7] - rotmat[5]) * S;
		q[1] = (rotmat[2] - rotmat[6]) * S;
		q[2] = (rotmat[3] - rotmat[1]) * S;
	}
	else if ((rotmat[0] > rotmat[4]) && (rotmat[0] > rotmat[8]))
	{
		float S = sqrt(1 + rotmat[0] - rotmat[4] - rotmat[8]) * 2;
		q[3] = (rotmat[6] - rotmat[5]) / S;
		q[0] = .25f * S;
		q[1] = (rotmat[1] + rotmat[3]) / S;
		q[2] = (rotmat[2] + rotmat[6]) / S;
	}
	else if (rotmat[4] > rotmat[8])
	{
		float S = sqrt(1 + rotmat[4] - rotmat[0] - rotmat[8]) * 2;
		q[3] = (rotmat[2] - rotmat[6]) / S;
		q[0] = (rotmat[1] + rotmat[3]) / S;
		q[1] = .25f * S;
		q[2] = (rotmat[5] + rotmat[7]) / S;
	}
	else
	{
		float S = sqrt(1 + rotmat[8] - rotmat[0] - rotmat[4]) * 2;
		q[3] = (rotmat[3] - rotmat[1]) / S;
		q[0] = (rotmat[2] + rotmat[6]) / S;
		q[1] = (rotmat[1] + rotmat[3]) / S;
		q[2] = .25f * S;
	}

	//Normalize the quaternion
	T = sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);

	q[0] = q[0] / T;
	q[1] = q[1] / T;
	q[2] = q[2] / T;
	q[3] = q[3] / T;
}